# Двоичное представление int, uint, float

## Полезные ссылки
Ридинги:
- Печатнов [тут](https://github.com/yuri-pechatnov/caos/tree/master/sem02-int-float-string-encoding)
- Яковлев [раз](https://github.com/victor-yacovlev/mipt-diht-caos/tree/master/practice/integers) [два](https://github.com/victor-yacovlev/mipt-diht-caos/tree/master/practice/ieee754)


## А зачем нам это обсуждать?  ~~ну инты и инты че бубнить то~~
Хороший вопрос! 

Смотрим в папочку [`bad-examples`](./bad-examples) и удивляемся тому какие опасные баги могут прятаться в коде, где люди неаккуратно работают с int/uint.

И, чтобы добить, заглянем в код [`openssh v3.3`](https://github.com/openssh/openssh-portable/blob/V_3_3/auth2-chall.c#L258) (утилиты которая позволяет по ssh подключаться к другим компам) и увидим любопытный кусок кода:
```c
nresp = packet_get_int();
if (nresp > 0) {
 response = xmalloc(nresp*sizeof(char*));
 for (i = 0; i < nresp; i++)
  response[i] = packet_get_string(NULL);
}
```
Ничего не напоминает? [`bad-examples/artihmetic-overflow-example.c`](./bad-examples/artihmetic-overflow-example.c) например...  
Для тех кому интересно:   
[описание](https://www.giac.org/paper/gcih/339/openssh-challenge-response-vulnerability/103617) конкретно этого эксплойта для OpenSSH.  
Интересная [статья](https://www.cs.utexas.edu/~shmat/courses/cs380s_fall09/blexim.txt) про всякие баги с integer overflow.  
И ещё [статья](https://www.welivesecurity.com/2022/02/21/integer-overflow-how-it-occur-can-be-prevented/) на эту тему.



## Беззнаковые целые числа
### Представление
Тут всё просто: просто двоичный код числа.
Проверяем   
```c
const uint32_t two = 2;
const uint32_t fifteen = 15;
const uint32_t very_big_value = 100500;

printf("2=0x%x, 15=0x%x, 100500=0x%x\n", two, fifteen, very_big_value);
// > 2=0x2, 15=0xf, 100500=0x18894
printf("UINT32_MAX=0x%x, UINT32_MAX+1=0x%x\n", UINT32_MAX, UINT32_MAX+1);
// > UINT32_MAX=0xffffffff, UINT32_MAX+1==0x0s
```

### Переполнение
*Условимся: когда речь будет идти о двоичном представлении чиселок, я буду ставить питонячее 0b перед числом, чтобы всем было удобнее.*

Переполнение беззнакового типа -- **нормальное поведение**, эквивалентное операции "сложение по модулю".
Больше тут особо и нечего говорить.

## Знаковые целые числа
### Прямой код
Прямой код - двоичное представление числа. В случае отрицательного числа, старший бит заменяется на единицу. Ясно, что с такими числами мега-неудобно работать: тяжело складывать и есть два нуля (положительный и отрицательный).

### Обратный код
В обратном коде старший бит отвечает за знак ("+" - 0, "-" - 1). После кода знака следует либо двоичный код (в случае положительного числа), либо инвертированный двоичный код в случае отрицательного числа.

Пример (4 разряда): 
```
    5 - 0b0101
   -5 - 0b1010
```

Тут уже получше: например, если сложить числа с разными знаками, не надо будет отдельно обрабатывать разные знаки, например:  
```
bin(0b0001 + 0b1010)            = 0b1011
    ^        ^
    |        |
    1      + -5 (обратный код)  = -0b100 = -4
```  

Но всё равно есть два нуля, это печально.
### Дополнительный код 
Ну вот и наш спаситель: в дополнительном коде, когда представляем отрицательное число, мы берём его обратный код и добавляем единичку.
Пример:
```
 5 - прямой код 0b0101
-5 - обратный   0b1010

    1010    <-
        +
    0001
    ===
    1011

    -5 - 0b1011
```

Ноль у нас, наконец, один! `0b0000`  
Теперь возьмём "бывший ноль" и посмотрим что из него получится:

```
    0b1111, отнимаем 0b0001 = 0b1110
    первый знак единичка, переводим в прямой код, получаем -0b001 - выходит минус единичка
```

Вуаля, хоть какого-то реглементированного способа хранения отрицательных чисел в стандарте языка си и нет, все современные компьютеры используют именно дополнительный код.
### Знаковое переполнение + UB = ❤️
https://www.airs.com/blog/archives/120
А вот знаковое переполнение у нас уже **UB**    

### UB 


## Как ловить overflow?
### GCC

### А как без приколов


## Float


