# Двоичное представление int, uint, float

## Полезные ссылки
Ридинги:
- Печатнов [тут](https://github.com/yuri-pechatnov/caos/tree/master/sem02-int-float-string-encoding)
- Яковлев [раз](https://github.com/victor-yacovlev/mipt-diht-caos/tree/master/practice/integers) [два](https://github.com/victor-yacovlev/mipt-diht-caos/tree/master/practice/ieee754)


## А зачем нам это обсуждать?  ~~ну инты и инты че бубнить то~~
Хороший вопрос! 

Смотрим в папочку [`bad-examples`](./bad-examples) и удивляемся тому какие опасные баги могут прятаться в коде, где люди неаккуратно работают с int/uint.

И, чтобы добить, заглянем в код [`openssh v3.3`](https://github.com/openssh/openssh-portable/blob/V_3_3/auth2-chall.c#L258) (утилиты которая позволяет по ssh подключаться к другим компам) и увидим любопытный кусок кода:
```c
nresp = packet_get_int();
if (nresp > 0) {
 response = xmalloc(nresp*sizeof(char*));
 for (i = 0; i < nresp; i++)
  response[i] = packet_get_string(NULL);
}
```
Ничего не напоминает? [`bad-examples/artihmetic-overflow-example.c`](./bad-examples/artihmetic-overflow-example.c) например...  
Для тех кому интересно:   
[описание](https://www.giac.org/paper/gcih/339/openssh-challenge-response-vulnerability/103617) конкретно этого эксплойта для OpenSSH.  
Интересная [статья](https://www.cs.utexas.edu/~shmat/courses/cs380s_fall09/blexim.txt) про всякие баги с integer overflow.  
И ещё [статья](https://www.welivesecurity.com/2022/02/21/integer-overflow-how-it-occur-can-be-prevented/) на эту тему.

Ещё интересные вещи связанные с integer (и не только) overflow:  
- [Проблема 2038 года](https://en.wikipedia.org/wiki/Year_2038_problem#Embedded_systems)
- Баг в боингах из-за которых надо было перезагружать самолёт каждые 250 дней, чтобы он не ломался. [статья](https://www.engadget.com/2015-05-01-boeing-787-dreamliner-software-bug.html) [не читайте первый комент, после него летать страшно](https://news.ycombinator.com/item?id=9476139)
## Беззнаковые целые числа
### Представление
Тут всё просто: просто двоичный код числа.
Проверяем   
```c
const uint32_t two = 2;
const uint32_t fifteen = 15;
const uint32_t very_big_value = 100500;

printf("2=0x%x, 15=0x%x, 100500=0x%x\n", two, fifteen, very_big_value);
// > 2=0x2, 15=0xf, 100500=0x18894
printf("UINT32_MAX=0x%x, UINT32_MAX+1=0x%x\n", UINT32_MAX, UINT32_MAX+1);
// > UINT32_MAX=0xffffffff, UINT32_MAX+1==0x0s
```

### Переполнение
*Условимся: когда речь будет идти о двоичном представлении чиселок, я буду ставить питонячее 0b перед числом, чтобы всем было удобнее.*

Переполнение беззнакового типа -- **нормальное поведение**, эквивалентное операции "сложение по модулю".
Больше тут особо и нечего говорить.

## Знаковые целые числа
### Прямой код
Прямой код - двоичное представление числа. В случае отрицательного числа, старший бит заменяется на единицу. Ясно, что с такими числами мега-неудобно работать: тяжело складывать и есть два нуля (положительный и отрицательный).

### Обратный код
В обратном коде старший бит отвечает за знак ("+" - 0, "-" - 1). После кода знака следует либо двоичный код (в случае положительного числа), либо инвертированный двоичный код в случае отрицательного числа.

Пример (4 разряда): 
```
  5 - 0b0101
 -5 - 0b1010
```

Тут уже получше: например, если сложить числа с разными знаками, не надо будет отдельно обрабатывать разные знаки, например:  
```
bin(0b0001 + 0b1010)            = 0b1011
    ^        ^
    |        |
    1      + -5 (обратный код)  = -0b100 = -4
```  

Но всё равно есть два нуля, это печально.
### Дополнительный код 
Ну вот и наш спаситель: в дополнительном коде, когда представляем отрицательное число, мы берём его обратный код и добавляем единичку.


Пример:
```
 5 - прямой код 0b0101
-5 - обратный   0b1010

    1010    <- обратный код
        +
    0001    <- единичка
    ===
    1011

    -5 - 0b1011
```

Ноль у нас, наконец, один! `0b0000`  
Теперь возьмём "бывший ноль" и посмотрим что из него получится:

```
    0b1111, отнимаем 0b0001 = 0b1110
    первый знак единичка, переводим в прямой код, получаем -0b001 - выходит минус единичка
```

Вуаля, хоть какого-то реглементированного способа хранения отрицательных чисел в стандарте языка си и нет, все современные компьютеры используют именно дополнительный код.
### Знаковое переполнение + UB = ❤️
А вот знаковое переполнение у нас уже **UB**, это компилятору делать достаточно прикольные оптимизации.
Ну например вот такая функция [check-signed-overflow.c](./compiler-optimizations/check-signed-overflow.c):
```c
int check_increment_signed(int32_t x) {
    return x + 1 > x;
}
```

Скоммпилируется у нас в следующий ассемблерный код (clang v14 arm64 macos, флаг -O3)
```
Disassembly of section __TEXT,__text:

0000000100003ef8 <_check_increment_signed>:
100003ef8: 20 00 80 52  mov     w0, #1 <--- всегда возвращается единица!
100003efc: c0 03 5f d6  ret
```


Ещё пример [infinite-loop.c](./compiler-optimizations/infinite-loop.c):
```c
int f()
{
    int i;
    int j = 0;
    for (i = 1; i > 0; i += i) {
        ++j;
    }
    return j;
}
```

Если скомпилировать на gcc v9.4.0 ubuntu x86-64, получается бесконечный цикл.
```
1140:	f3 0f 1e fa          	endbr64
1144:	0f 1f 40 00          	nopl   0x0(%rax)  <- ничего
1148:	eb fe                	jmp    1148 <f+0x8> // infinite loop
114a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1) <- ничего
```

Как раз из-за того что знаковое переполнение UB компилятор, считая что в правильных программах переполнения не будет, оптимизирует подобный код и избавляется от таких кусков.

## Как ловить overflow? 
Первый вариант - пользоваться санитайзерами. Это специальные программы, которые генерируют исполняемый код и (что немаловажно) в рантайме проверяют ситуации в том числе связанные с переполнением. Естественно эта помощь приходит не бесплатно и обычно с санитайзерами программа может сильно медленнее исполняться и потреблять больше памяти.

Второй вариант - не допускать overflow изначально. Делать это можно как самостоятельно, например проверками в духе:
<!-- src: https://codereview.stackexchange.com/questions/37177/simple-method-to-detect-int-overflow -->
```c
#include <limits.h>

int safe_add(int a, int b) {
    if (a > 0 && b > INT_MAX - a) {
        /* handle overflow */
    } else if (a < 0 && b < INT_MIN - a) {
        /* handle underflow */
    }
    return a + b;
}
```

Ещё можно пользоваться либо специальными библиотекам (BigNum, SafeInt), либо пользоваться **нестандартными** встроенными функциями с контролем переполнения. Список копипастить не буду, он есть в [ридинге Яковлева](https://github.com/victor-yacovlev/fpmi-caos/tree/master/practice/integers#%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C-%D0%BF%D0%B5%D1%80%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BD%D0%B5%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE-%D0%BE%D1%82-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%B2%D0%BE%D1%81%D1%82%D0%B8).

Пример кода:
```c
  int result;
  int a = 12;
  int b = INT32_MAX-15;
  printf("%d\n", __builtin_sadd_overflow (a, b, &result));
```

## float & double
Для хранения чисел с плавающей точкой используются два типа: float (4 байта), double (8 байт).
`[-2**(n-1); 2**(n-1)-1]`

Вычисляем значение при помощи следующей формулы:
```
Value = (-1) ^ S * 2 ^ (E - B) * ( 1 + M / (2^M_bits - 1) )

S - знак
B - смещение                                        127 float, 1023 double
M - мантисса,
M_bits - количество бит в экспоненте                23  float,  52  double
```
Для double
```
S EEEEEEEEEEE MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
1 --11 bits-- ------------------52 bits (M_bits)------------------      
```

Пример перевода чиселки в IEEE754:
```
x = (-1) ** S * (1 + fraction) * 2 ** pow

42.15 / (2 ** pow) = 1 + fraction <- перебираем pow пока не получим нужный вид справа (fraction < 1)

pow = 5, fraction = 0.3171875
E-1023=5 => E = 1028, E=0b10000000100

S = 1
Дальше переводим 0.3171875 в двоичную чиселку

0.3171875 * 2 0.
0.634375  * 2 1.
0.26875   * 2 0.
0.5375    * 2 1.
0.075     * 2 0.
0.15      * 2 0.
0.3       * 2 0.
0.6       * 2 1.  -+
0.2       * 2 0.   | <-- паттерн повторяется, берём пока не добираем до 52 
0.4       * 2 0.   |
0.8       * 2 1.  -+
0.6       * 2 1.
0.2       * 2 0.
0.4       * 2 0.
0.8       * 2 1.
0.6       * 2 1.
 
Выхлоп:
1 10000000100 0101000100110011001100110011001100110011001100110011
```

Если E=0, то перед нами денормализованное число (они используются для того,чтбоы представлять совсем маленькие чиселки. 

Value = (-1)^S * ( M / (2^M_bits - 1) )


### union 

На битики числа с плавающей точкой можно смотреть двумя способами:
```c
double a = 3.14159;

typedef union {
    double     real_value;
    uint64_t   uint_value;
} real_or_uint;

real_or_uint u;
u.real_value = a;
uint64_t b = u.uint_value;
```
### cast

Либо можно делать вот так:
```c
// У нас есть некоторое целое вещественное число, которое хранится в памяти
double a = 3.14159;

// Получаем указатель на это число
double* a_ptr_as_double = &a;

// Теряем информацию о типе, приведением его к типу void*
void* a_ptr_as_void = a_ptr_as_void;

// Указатель void* в языке Си можно присваивать любому указателю
uint64_t* a_ptr_as_uint = a_ptr_as_void;

// Ну а дальше просто разыменовываем указатель
uint64_t b = *a_as_uint;
```


## Специальные значения
Кроме обычных чиселок, в IEEE754 есть спеицальные значения, которыми можно представить NaN, Inf, -Inf и тд.
Об этом есть задача, в которой будет возможность разобраться что происходит. [Тут](https://github.com/victor-yacovlev/fpmi-caos/tree/master/practice/math#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B2-%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B5-ieee754) референс, который может помочь.